#' @title Perform k-means clustering from a musica result object
#' @description Proportional sample exposures will be used as input for the 
#' \code{\link[stats]{kmeans}} function to perform clustering.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param ... Arguments of \code{\link[stats]{kmeans}} function.
#' @return A one-column data frame with sample IDs as row names and cluster number for each sample.
#' @seealso \link[stats]{kmeans}
#' @examples 
#' data(res_annot)
#' Kmeans(res_annot, centers = 2)
#' @export

Kmeans <- function(result, ...){
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  k_res <- kmeans(expos, ...)
  k_out <- data.frame(cluster = factor(unname(k_res$cluster)))
  rownames(k_out) <- names(k_res$cluster)
  return(k_out)
}

#' @title Visualize k-means clustering results
#' @description The k-means clustering results can be visualized on a UMAP panel. 
#' Three different types of plots can be generated using this function: cluster-by-signature 
#' plot, cluster-by-annotation plot, and a single UMAP plot.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool. A two-dimensional UMAP has to
#' be stored in this object.
#' @param clusters The result generated from Kmeans function.
#' @param group A single character string indicating the grouping factor. 
#' Possible options are: "signature" (columns are signatures in a grid), 
#' "annotation" (columns are sample annotation), and "none" (a single UMAP plot). 
#' Default is "signature".
#' @param sample_col Sample column name of the annotation table added to result 
#' object. Only used when "group" specified as "annotation".
#' @return Generate a ggplot object.
#' @seealso \link{create_umap}
#' @examples 
#' data(res_annot)
#' #Get k-means result
#' k_out <- Kmeans(res_annot, centers = 2)
#' #generate cluster X signature plot
#' plot_Kmeans(res_annot, k_out, group = "signature")
#' #generate cluster X annotation plot
#' plot_Kmeans(res_annot, k_out, group = "annotation", sample_col = "Samples")
#' #generate a single UMAP plot
#' plot_Kmeans(res_annot, k_out, group = "none")
#' @export

plot_Kmeans <- function(result, clusters, group = c('signature', 'annotation', 'none'), sample_col = NULL){
  group <- match.arg(group)
  k_toplot <- cbind(result@umap, clusters)
  if(group == "signature"){
    expos <- exposures(result = result)
    expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
    clust_by_sigs <- cbind(k_toplot, expos) %>%
      tibble::rownames_to_column(var = "sample") %>%
      tidyr::pivot_longer(cols = colnames(expos),
                          names_to = "signature",
                          values_to = "exposure",
                          names_repair = "minimal")
    ggplot(clust_by_sigs, aes(x = UMAP_1, y = UMAP_2, colour = exposure)) +
      geom_point() +
      facet_grid(cluster ~ signature) +
      ggplot2::scale_colour_gradientn(colors = c("blue","green","yellow","orange","red"), name = "Fraction")
  }
  else if(group == "annotation"){
    if(is.null(result@musica@sample_annotations)) {stop("Sample annotation not found.")}
    else{
      annot <- result@musica@sample_annotations %>% tibble::column_to_rownames(var = sample_col)
      colnames(annot) <- "tumor_subtype"
      annot$tumor_subtype <- factor(annot$tumor_subtype)
      clust_by_annot <- cbind(k_toplot, annot)
      ggplot(clust_by_annot, aes(x = UMAP_1, y = UMAP_2, colour = cluster)) +
        geom_point() +
        facet_grid(cluster ~ tumor_subtype)
    }
  }
  else{
    ggplot(k_toplot, aes(x = UMAP_1, y = UMAP_2, colour = cluster)) +
      geom_point()
  }
}

#' @title Plots for helping decide number of clusters for k-means
#' @description To help decide the number of cluster for k-means, three different methods 
#' are provided: total within cluster sum of squares, average silhouette coefficient, 
#' and gap statistics.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param method A single character string indicating which statistic to use for plot. 
#' Options are "elbow" (total within cluster sum of squares), "silhouette" (average silhouette 
#' coefficient), and "gap" (gap statistic). Default is "elbow".
#' @param n An integer indicating maximum number of clusters to test. Default is 10.
#' @return A ggplot object.
#' @seealso \link[factoextra]{fviz_nbclust}
#' @examples 
#' #####withr::with_seed()
#' set.seed(123)
#' data(res_annot)
#' #Make an elbow plot
#' k_select(res_annot, method = "elbow", n = 7)
#' #Plot average silhouette coefficient against number of clusters
#' k_select(res_annot, method = "silhouette", n = 7)
#' #Plot gap statistics against number of clusters
#' k_select(res_annot, method = "gap", n =7)
#' @export

k_select <- function(result, method = c('elbow', 'silhouette', 'gap'), n = 10){
  require(factoextra)
  method <- match.arg(method)
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  if(method == "elbow"){
    fviz_nbclust(expos, kmeans, method = "wss", k.max = n)
  }
  else if(method == "silhouette"){
    fviz_nbclust(expos, kmeans, method = "silhouette", k.max = n)
  }
  else{
    fviz_nbclust(expos, kmeans, method = "gap_stat", k.max = n)
  }
}
