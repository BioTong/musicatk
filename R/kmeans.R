#' @title Perform k-means clustering from a musica result object
#' @description Proportional sample exposures will be used as input for the 
#' \code{\link[stats]{kmeans}} function to perform clustering.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param ... Arguments of \code{\link[stats]{kmeans}} function.
#' @return A one-column data frame with sample IDs as row names and cluster number for each sample.
#' @seealso \link[stats]{kmeans}
#' @examples 
#' data(res_annot)
#' k_out <- withr::with_seed(123, Kmeans(res_annot, centers = 2))
#' @export

Kmeans <- function(result, ...){
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  k_res <- stats::kmeans(expos, ...)
  k_out <- data.frame(cluster = factor(unname(k_res$cluster)))
  rownames(k_out) <- names(k_res$cluster)
  return(k_out)
}

#' @title Visualize k-means clustering results
#' @description The k-means clustering results can be visualized on a UMAP panel. 
#' Three different types of plots can be generated using this function: cluster-by-signature 
#' plot, cluster-by-annotation plot, and a single UMAP plot.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool. A two-dimensional UMAP has to
#' be stored in this object.
#' @param clusters The result generated from Kmeans function.
#' @param group A single character string indicating the grouping factor. 
#' Possible options are: "signature" (columns are signatures in a grid), 
#' "annotation" (columns are sample annotation), and "none" (a single UMAP plot). 
#' Default is "signature".
#' @return Generate a ggplot object.
#' @seealso \link{create_umap}
#' @examples 
#' data(res_annot)
#' #Get k-means result
#' k_out <- withr::with_seed(123, Kmeans(result = res_annot, centers = 2))
#' #UMAP
#' create_umap(result = res_annot)
#' #generate cluster X signature plot
#' plot_Kmeans(result = res_annot, clusters = k_out, group = "signature")
#' #generate cluster X annotation plot
#' plot_Kmeans(result = res_annot, clusters = k_out, group = "annotation")
#' #generate a single UMAP plot
#' plot_Kmeans(result = res_annot, clusters = k_out, group = "none")
#' @export

plot_Kmeans <- function(result, clusters, group = c('signature', 'annotation', 'none')){
  group <- match.arg(group)
  if(length(result@umap) == 0){
    stop(paste("UMAP not found in musica_result object. Run create_umap(", deparse(substitute(result)),") first."), sep = "")
  }
  else{
    k_toplot <- cbind(result@umap, clusters)
    if(group == "signature"){
      expos <- exposures(result = result)
      expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
      clust_by_sigs <- cbind(k_toplot, expos) %>%
        tibble::rownames_to_column(var = "sample") %>%
        tidyr::pivot_longer(cols = colnames(expos),
                            names_to = "signature",
                            values_to = "exposure",
                            names_repair = "minimal")
      ggplot2::ggplot(clust_by_sigs, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "exposure")) +
        geom_point() +
        facet_grid(cluster ~ signature) +
        ggplot2::scale_colour_gradientn(colors = c("blue","green","yellow","orange","red"), name = "Fraction")
    }
    else if(group == "annotation"){
      if(ncol(result@musica@sample_annotations) == 1) {stop("Sample annotation not found.")}
      else{
        annot <- result@musica@sample_annotations %>% tibble::column_to_rownames(var = "Samples")
        colnames(annot) <- "tumor_subtype"
        annot$tumor_subtype <- factor(annot$tumor_subtype)
        clust_by_annot <- cbind(k_toplot, annot)
        ggplot2::ggplot(clust_by_annot, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "cluster")) +
          geom_point() +
          facet_grid(cluster ~ tumor_subtype)
      }
    }
    else{
      ggplot2::ggplot(k_toplot, aes_string(x = "UMAP_1", y = "UMAP_2", colour = "cluster")) +
        geom_point()
    }
  }
}

#' @title Plots for helping decide number of clusters for k-means
#' @description To help decide the number of cluster for k-means, three different methods 
#' are provided: total within cluster sum of squares, average silhouette coefficient, 
#' and gap statistics.
#' @param result A \code{\linkS4class{musica_result}} object generated by
#' a mutational discovery or prediction tool.
#' @param method A single character string indicating which statistic to use for plot. 
#' Options are "elbow" (total within cluster sum of squares), "silhouette" (average silhouette 
#' coefficient), and "gap" (gap statistic). Default is "elbow".
#' @param n An integer indicating maximum number of clusters to test. Default is 10.
#' @return A ggplot object.
#' @seealso \link[factoextra]{fviz_nbclust}
#' @examples 
#' data(res_annot)
#' #Make an elbow plot
#' withr::with_seed(123, k_select(res_annot, method = "elbow", n = 6))
#' #Plot average silhouette coefficient against number of clusters
#' withr::with_seed(123, k_select(res_annot, method = "silhouette", n = 6))
#' #Plot gap statistics against number of clusters
#' withr::with_seed(123, k_select(res_annot, method = "gap", n =6))
#' @export

k_select <- function(result, method = c('elbow', 'silhouette', 'gap'), n = 10){
  method <- match.arg(method)
  expos <- exposures(result = result)
  expos <- t(sweep(expos, 2, colSums(expos), FUN = "/"))
  if(method == "elbow"){
    factoextra::fviz_nbclust(expos, kmeans, method = "wss", k.max = n)
  }
  else if(method == "silhouette"){
    factoextra::fviz_nbclust(expos, kmeans, method = "silhouette", k.max = n)
  }
  else{
    factoextra::fviz_nbclust(expos, kmeans, method = "gap_stat", k.max = n)
  }
}
